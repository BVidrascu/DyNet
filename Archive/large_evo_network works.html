<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>Dynamic Social Network</title>
  <link rel="icon" href="dynet_logo.png" type="image/png">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>
  <style>
      body {
          margin: 0;
          padding: 20px;
          font-family: 'Poppins', sans-serif;
          background: #f0f0f0;
      }
      .container {
          max-width: 1000px;
          margin: 0 auto;
          background: white;
          border-radius: 10px;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
          padding: 20px;
      }
      .title {
          text-align: center;
          margin-bottom: 1rem;
          font-size: 1.25rem;
          font-weight: bold;
      }
      .description {
          text-align: center;
          color: #666;
          margin-bottom: 1.5rem;
          font-size: 0.875rem;
      }
      .controls {
          display: flex;
          flex-wrap: wrap;
          gap: 10px;
          margin-bottom: 20px;
          justify-content: center;
          align-items: center;
      }
      .control-group {
          display: flex;
          gap: 10px;
          flex-wrap: wrap;
          justify-content: center;
          align-items: center;
      }
      button {
          padding: 8px 16px;
          border: 0.5px solid rgba(173, 216, 230, 0.25);
          border-radius: 10px;
          background-color: rgba(173, 216, 230, 0.25);
          -webkit-backdrop-filter: blur(4px);
          backdrop-filter: blur(4px);
          color: #333;
          cursor: pointer;
          font-size: 14px;
          font-family: 'Poppins', sans-serif;
          box-shadow: 0 3px 10px 0 rgba(31, 38, 135, 0.37);
          transition: 1s all ease;
          z-index: 10;
      }
      button:hover {
          background-color: rgba(105, 196, 226, 0.35);
          box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
          transform: translateY(-1px);
      }
      button:disabled {
          background-color: rgba(170, 170, 170, 0.25);
          cursor: not-allowed;
          transform: none;
          box-shadow: none;
      }
      .slider-container {
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 5px;
      }
      input[type="range"] {
          width: 200px;
      }
      @keyframes drawEdge {
          to {
              stroke-dashoffset: 0;
          }
      }
      .edge-line {
          stroke-dasharray: 1000;
          stroke-dashoffset: 1000;
          animation: drawEdge 0.5s ease-out forwards;
      }
      /* Help modal styles */
      .help-modal {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: rgba(0,0,0,0.6);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 100;
      }
      .help-modal-content {
          background: white;
          padding: 20px;
          border-radius: 8px;
          max-width: 600px;
          width: 90%;
          font-family: 'Poppins', sans-serif;
      }
      .help-modal-content h2 {
          margin-top: 0;
      }
      .stats {
          display: flex;
          justify-content: space-around;
          margin: 10px 0;
          font-size: 14px;
      }
      .stat-item {
          text-align: center;
      }
      .stat-value {
          font-weight: bold;
          font-size: 16px;
      }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
      

      const interpolateColor = (color1, color2, factor) => {
          if (factor <= 0) return color1;
          if (factor >= 1) return color2;
          
          // Convert hex to RGB
          const hex2rgb = (hex) => {
              const r = parseInt(hex.slice(1, 3), 16);
              const g = parseInt(hex.slice(3, 5), 16);
              const b = parseInt(hex.slice(5, 7), 16);
              return [r, g, b];
          };
          
          const [r1, g1, b1] = hex2rgb(color1);
          const [r2, g2, b2] = hex2rgb(color2);
          
          // Interpolate
          const r = Math.round(r1 + factor * (r2 - r1));
          const g = Math.round(g1 + factor * (g2 - g1));
          const b = Math.round(b1 + factor * (b2 - b1));
          
          // Convert back to hex
          return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
      };

      const width = 900;
      const height = 680;
      const centerX = width / 2;
      const centerY = height / 2;

      // Generate 100 nodes with a random but circular distribution
      const fixedNodes = [];
      const numNodes = 200;
      
      // Helper function to check if a position is too close to existing nodes
      const isTooClose = (x, y, minDistance = 30) => {
          for (const node of fixedNodes) {
              const dx = node.x - x;
              const dy = node.y - y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              if (distance < minDistance) {
                  return true;
              }
          }
          return false;
      };
      
      // Generate nodes in a circular pattern with randomness
      for (let i = 0; i < numNodes; i++) {
          let x, y;
          let attempts = 0;
          const maxAttempts = 50;
          
          do {
              // Use a circular distribution with some randomness
              // This creates a more rounded overall shape but with random spacing
              const angle = Math.random() * 2 * Math.PI;
              
              // Random radius that concentrates more nodes toward the center
              // but ensures coverage throughout the area
              let radius;
              const distribution = Math.random();
              
              if (distribution < 0.25) {
                  // 25% of nodes in the inner area
                  radius = 80 + Math.random() * 60;
              } else if (distribution < 0.75) {
                  // 50% of nodes in the middle area
                  radius = 140 + Math.random() * 100;
              } else {
                  // 25% of nodes in the outer area
                  radius = 240 + Math.random() * 70;
              }
              
              // Add some random variation to break perfect circularity
              // but maintain the overall rounded look
              const variationFactor = 0.2; // 20% variation maximum
              const angleVariation = (Math.random() * 2 - 1) * 0.05 * Math.PI;
              const adjustedAngle = angle + angleVariation;
              const radiusVariation = 1 + (Math.random() * 2 - 1) * variationFactor;
              const adjustedRadius = radius * radiusVariation;
              
              // Calculate position
              x = centerX + adjustedRadius * Math.cos(adjustedAngle);
              y = centerY + adjustedRadius * Math.sin(adjustedAngle);
              
              // Ensure point is within canvas bounds
              x = Math.max(30, Math.min(width - 30, x));
              y = Math.max(30, Math.min(height - 30, y));
              
              attempts++;
              
              // If we can't find a good position after many attempts, reduce spacing requirements
              if (attempts > maxAttempts) {
                  if (!isTooClose(x, y, 20)) {
                      break;
                  }
                  if (attempts > maxAttempts * 1.5) {
                      break;
                  }
              }
          } while (isTooClose(x, y));
          
          fixedNodes.push({
              id: i + 1,
              x,
              y
          });
      }

      // Assign initial groups based on position within the circular network
      const initialGroups = fixedNodes.map((node, i) => {
          // Calculate node's distance from center
          const dx = node.x - centerX;
          const dy = node.y - centerY;
          const distanceFromCenter = Math.sqrt(dx * dx + dy * dy);
          
          // Calculate angle (in radians) of the node from center
          // 0 is right, π/2 is bottom, π is left, 3π/2 is top
          let angle = Math.atan2(dy, dx);
          if (angle < 0) angle += 2 * Math.PI; // Normalize to 0-2π
          
          // Create a gradient of probabilities based on position
          // Left half (angle between π/2 and 3π/2) has more non-smokers
          if (angle > Math.PI/2 && angle < 3*Math.PI/2) {
              return Math.random() < 0.80 ? 1 : 2; // 75% non-smokers on left
          } 
          // Right half has more smokers
          else {
              return Math.random() < 0.40 ? 1 : 2; // % non-smokers on right
          }
      });

      // Node colors: Group 1 (non-smokers) uses light gray, Group 2 (smokers) uses dark red.
    const colors = ['#d3d3d3', '#ff4d4d'];

      // Generate a sequence of changes to the network
      // We'll generate these programmatically to handle the larger network
      const changes = [];
      
      
      // Helper function to find nearby nodes
      const findNearbyNodes = (nodeId, maxDistance = 100) => {
          const node = fixedNodes[nodeId - 1];
          const nearbyNodes = [];
          
          for (let i = 0; i < fixedNodes.length; i++) {
              if (i + 1 !== nodeId) { // Skip self
                  const otherNode = fixedNodes[i];
                  const dx = otherNode.x - node.x;
                  const dy = otherNode.y - node.y;
                  const distance = Math.sqrt(dx * dx + dy * dy);
                  
                  if (distance <= maxDistance) {
                      nearbyNodes.push(i + 1);
                  }
              }
          }
          
          return nearbyNodes;
      };
      
      // Create initial connections - each node connects to 1-2 nearest nodes (halved)
      const initialEdges = [];
      for (let i = 0; i < fixedNodes.length; i++) {
          const nodeId = i + 1;
          const nearbyNodes = findNearbyNodes(nodeId, 100).sort((a, b) => {
              const nodeA = fixedNodes[a - 1];
              const nodeB = fixedNodes[b - 1];
              const nodeSource = fixedNodes[i];

              const distA = Math.sqrt(Math.pow(nodeA.x - nodeSource.x, 2) + Math.pow(nodeA.y - nodeSource.y, 2));
              const distB = Math.sqrt(Math.pow(nodeB.x - nodeSource.x, 2) + Math.pow(nodeB.y - nodeSource.y, 2));

              return distA - distB;
          });

          // Connect to 1-2 closest nodes (reduced from 2-4)
          const connectionCount = 1 + Math.floor(Math.random() * 2);
          for (let j = 0; j < Math.min(connectionCount, nearbyNodes.length); j++) {
              const targetNodeId = nearbyNodes[j];
              // Avoid duplicate connections by only connecting if source < target
              if (nodeId < targetNodeId) {
                  initialEdges.push({
                      source: nodeId,
                      target: targetNodeId,
                      key: `${nodeId}-${targetNodeId}`,
                      progress: 1, // Fully drawn initially
                  });
              }
          }
      }

      // Add some longer distance connections to create "small world" network properties
      const longConnections = 60; // Increased from 30
      for (let i = 0; i < longConnections; i++) {
          const sourceNodeId = Math.floor(Math.random() * fixedNodes.length) + 1;
          let targetNodeId;
          
          // Find a node that's far away from the source
          do {
              targetNodeId = Math.floor(Math.random() * fixedNodes.length) + 1;
          } while (
              sourceNodeId === targetNodeId || 
              findNearbyNodes(sourceNodeId, 150).includes(targetNodeId)
          );
          
          changes.push({ type: 'edge', action: 'add', source: Math.min(sourceNodeId, targetNodeId), target: Math.max(sourceNodeId, targetNodeId) });
      }
      
      // Find initial "seed" smoker nodes - start with just a few nodes
      // We'll pick 3 nodes from the right side that are already smokers
      const initialSeeders = fixedNodes
          .map((node, index) => ({ node, index: index + 1, group: initialGroups[index] }))
          .filter(item => item.group === 2 && item.node.x > centerX + 100);
          
      // Sort by distance from center to get varied starting points
      initialSeeders.sort((a, b) => {
          const distA = Math.sqrt(Math.pow(a.node.x - centerX, 2) + Math.pow(a.node.y - centerY, 2));
          const distB = Math.sqrt(Math.pow(b.node.x - centerX, 2) + Math.pow(b.node.y - centerY, 2));
          return distA - distB;
      });
      
      // Select a few spread out nodes as initial influencers
      const infectionPoints = [];
      if (initialSeeders.length >= 3) {
          infectionPoints.push(initialSeeders[0].index); // One close to center
          infectionPoints.push(initialSeeders[Math.floor(initialSeeders.length / 2)].index); // One in middle
          infectionPoints.push(initialSeeders[initialSeeders.length - 1].index); // One at edge
      } else {
          // Fallback if we don't have enough initial smokers
          for (let i = 0; i < Math.min(3, initialSeeders.length); i++) {
              infectionPoints.push(initialSeeders[i].index);
          }
      }
      
      // Remove resistance centers to allow smoking to spread more effectively
      const resistancePoints = [];
      
      // Simulate "spread" of smoking behavior with increasing influence over time
      const processedNodes = new Set([...infectionPoints]);
      const spreadQueue = [...infectionPoints];
      
      // Initialize a wave counter for increasing influence
      let waveCount = 0;
      const maxWaves = 25; // Control the overall extent of spread
      
      while (spreadQueue.length > 0 && waveCount < maxWaves) {
          waveCount++;
          
          // Get the number of nodes to process in this wave
          // Process more nodes in each successive wave
          const nodesInWave = Math.min(spreadQueue.length, 3 + Math.floor(waveCount / 3));
          const currentWaveNodes = [];
          
          // Take nodes from the queue for this wave
          for (let i = 0; i < nodesInWave; i++) {
              if (spreadQueue.length > 0) {
                  currentWaveNodes.push(spreadQueue.shift());
              }
          }
          
          // Process each node in the current wave
          for (const sourceNodeId of currentWaveNodes) {
              // Find nearby nodes with increasing radius over time
              // This simulates the growing influence of smoking behavior
              const searchRadius = 100 + Math.min(waveCount * 5, 150);
              const nearbyNodes = findNearbyNodes(sourceNodeId, searchRadius);
              
              for (const targetNodeId of nearbyNodes) {
                  if (!processedNodes.has(targetNodeId)) {
                      // Increased probability of conversion over time
                      // Early waves have lower influence, later waves have higher influence
                      const baseProb = 0.6; // Starting probability
                      const dynamicInfluence = (waveCount / maxWaves) * 0.35; // Make influence grow, cap at 0.35
                      const conversionProb = Math.min(baseProb + dynamicInfluence, 0.9); // Ensure prob doesn't exceed 0.9

                      if (Math.random() < conversionProb) {
                          if (Math.random() < 0.15) { // Decreased from 0.5 to make color changes much less frequent here
                              changes.push({ type: 'color', nodeId: targetNodeId, newGroup: 2 });
                              processedNodes.add(targetNodeId);
                              spreadQueue.push(targetNodeId);
                          }
                      }
                  }
              }
          }
      }
      
      // Add some edge deletions to simulate changing social relationships
      const numEdgeDeletions = 15;
      for (let i = 0; i < numEdgeDeletions; i++) {
          const edgeIdx = Math.floor(Math.random() * (changes.length * 0.6)); // Get from first 60% of edges
          const edge = changes[edgeIdx];
          
          if (edge.type === 'edge' && edge.action === 'add') {
              // Add deletion of this edge later in the sequence
              changes.push({ 
                  type: 'edge', 
                  action: 'delete', 
                  source: edge.source, 
                  target: edge.target 
              });
          }
      }
      
      // Add some new connections forming later in the simulation (smoker to smoker preferentially)
      const newLateConnections = 40; // Increased from 20
      for (let i = 0; i < newLateConnections; i++) {
          // Prefer smokers for new connections
          const smokerNodes = [];
          for (let j = 0; j < fixedNodes.length; j++) {
              if (initialGroups[j] === 2) {
                  smokerNodes.push(j + 1);
              }
          }
          
          const sourceNodeId = smokerNodes[Math.floor(Math.random() * smokerNodes.length)];
          const nearbyNodes = findNearbyNodes(sourceNodeId, 120).filter(id => 
              !changes.some(change => 
                  change.type === 'edge' && 
                  change.action === 'add' && 
                  ((change.source === sourceNodeId && change.target === id) || 
                   (change.source === id && change.target === sourceNodeId))
              )
          );
          
          if (nearbyNodes.length > 0) {
              const targetNodeId = nearbyNodes[Math.floor(Math.random() * nearbyNodes.length)];
              changes.push({ 
                  type: 'edge', 
                  action: 'add', 
                  source: Math.min(sourceNodeId, targetNodeId), 
                  target: Math.max(sourceNodeId, targetNodeId) 
              });
          }
      }
      
      // Limit to a reasonable number of changes to avoid overwhelming the UI
      if (changes.length > 300) {
          changes.splice(300);
      }

      const calculateNodeDegrees = (links) => {
          const degrees = Array(fixedNodes.length).fill(0);
          links.forEach((link) => {
              degrees[link.source - 1]++;
              degrees[link.target - 1]++;
          });
          return degrees;
      };

      function App() {
          const [step, setStep] = React.useState(0);
          const [nodeGroups, setNodeGroups] = React.useState(initialGroups);
          const [activeLinks, setActiveLinks] = React.useState(initialEdges);
          const [flashingNode, setFlashingNode] = React.useState(null);
          const [flashCount, setFlashCount] = React.useState(0);
          const [isPlaying, setIsPlaying] = React.useState(false); // Start paused for large network
          const [isSoundEnabled, setIsSoundEnabled] = React.useState(false);
          const [speed, setSpeed] = React.useState(500); // Default faster for large network
          const [showHelp, setShowHelp] = React.useState(false);
          const [nodesPerGroup, setNodesPerGroup] = React.useState({
              group1: nodeGroups.filter(g => g === 1).length,
              group2: nodeGroups.filter(g => g === 2).length
          });
          const intervalRef = React.useRef(null);
          const flashIntervalRef = React.useRef(null);
          const nextAutomaticChangeRef = React.useRef(50); // For tracking automatic changes

          const [dynamicFixedNodes, setDynamicFixedNodes] = React.useState(fixedNodes);
          const [nodeIsolationCounters, setNodeIsolationCounters] = React.useState(
              Array(fixedNodes.length).fill(0)
          );
          const [addedNodeCount, setAddedNodeCount] = React.useState(0); 
          const [removedNodeCount, setRemovedNodeCount] = React.useState(0);
          const [lastNodeRemovalStep, setLastNodeRemovalStep] = React.useState(-50); // Prevent immediate removals

          const findEmptySpot = () => {
              const maxAttempts = 100;
              const minDistance = 40; // Minimum distance to other nodes
              
              for (let attempt = 0; attempt < maxAttempts; attempt++) {
                  // Generate random position within the canvas
                  const x = Math.random() * (width - 60) + 30;
                  const y = Math.random() * (height - 60) + 30;
                  
                  // Check if this position is too close to any existing node
                  let isTooClose = false;
                  for (const node of dynamicFixedNodes) {
                      const dx = node.x - x;
                      const dy = node.y - y;
                      const distance = Math.sqrt(dx * dx + dy * dy);
                      if (distance < minDistance) {
                          isTooClose = true;
                          break;
                      }
                  }
                  
                  if (!isTooClose) {
                      return { x, y };
                  }
              }
              
              // If we couldn't find a spot after many attempts, return a position
              // in a less crowded area of the graph
              return { 
                  x: Math.random() * (width - 60) + 30,
                  y: Math.random() * (height - 60) + 30
              };
          };

          const addNewNode = () => {
              if (addedNodeCount >= 4) return; // Limit to 4 new nodes maximum
              
              const position = findEmptySpot();
              const newNodeId = dynamicFixedNodes.length + 1;
              
              // Add the new node
              setDynamicFixedNodes(prev => [...prev, { 
                  id: newNodeId, 
                  x: position.x, 
                  y: position.y 
              }]);
              
              // Set initial group (likely non-smoker)
              setNodeGroups(prev => [...prev, Math.random() < 0.8 ? 1 : 2]);
              
              // Initialize isolation counter for the new node
              setNodeIsolationCounters(prev => [...prev, 0]);
              
              // Update statistics
              setNodesPerGroup(prev => {
                  const newGroup = nodeGroups[newNodeId - 1] || 1; // Fallback to group 1
                  return {
                      group1: prev.group1 + (newGroup === 1 ? 1 : 0),
                      group2: prev.group2 + (newGroup === 2 ? 1 : 0)
                  };
              });
              
              setAddedNodeCount(prev => prev + 1);
          };

          const removeIsolatedNode = () => {
              // Don't remove nodes too frequently
              if (step - lastNodeRemovalStep < 50 || removedNodeCount >= 3) return;
              
              // Find isolated nodes (no connections for a while)
              const isolatedNodeIndices = nodeIsolationCounters
                  .map((counter, index) => ({ index, counter }))
                  .filter(item => item.counter > 30) // Must be isolated for 30+ steps
                  .map(item => item.index);
              
              if (isolatedNodeIndices.length === 0) return;
              
              // Choose a random isolated node to remove
              const indexToRemove = isolatedNodeIndices[
                  Math.floor(Math.random() * isolatedNodeIndices.length)
              ];
              const nodeIdToRemove = dynamicFixedNodes[indexToRemove].id;
              
              // Remove the node
              setDynamicFixedNodes(prev => 
                  prev.filter((_, index) => index !== indexToRemove)
              );
              
              // Update nodeGroups - keep the mapping by ID rather than index
              const updatedGroups = [...nodeGroups];
              updatedGroups[nodeIdToRemove - 1] = undefined; // Mark as removed in the groups array
              setNodeGroups(updatedGroups);
              
              // Update isolation counters
              setNodeIsolationCounters(prev => 
                  prev.filter((_, index) => index !== indexToRemove)
              );
              
              // Remove any edges connected to this node
              setActiveLinks(prev => 
                  prev.filter(link => 
                      link.source !== nodeIdToRemove && link.target !== nodeIdToRemove
                  )
              );
              
              // Update statistics
              setNodesPerGroup(prev => {
                  const removedGroup = nodeGroups[nodeIdToRemove - 1];
                  return {
                      group1: prev.group1 - (removedGroup === 1 ? 1 : 0),
                      group2: prev.group2 - (removedGroup === 2 ? 1 : 0)
                  };
              });
              
              setRemovedNodeCount(prev => prev + 1);
              setLastNodeRemovalStep(step);
          };

          const calculateNodeDegrees = (links, nodes = dynamicFixedNodes) => {
              const maxNodeId = nodes.reduce((max, node) => Math.max(max, node.id), 0);
              const degrees = Array(maxNodeId).fill(0);
              
              links.forEach((link) => {
                  if (link.source > 0 && link.source <= degrees.length) {
                      degrees[link.source - 1]++;
                  }
                  if (link.target > 0 && link.target <= degrees.length) {
                      degrees[link.target - 1]++;
                  }
              });
              
              return degrees;
          };

          const handleFlash = (nodeId, oldGroup, newGroup) => {
              setFlashingNode(nodeId);
              setFlashCount(0);
              
              if (flashIntervalRef.current) {
                  clearInterval(flashIntervalRef.current);
              }
              
              // Start transition animation
              const startTime = Date.now();
              const transitionDuration = 600;
              
              const animateTransition = () => {
                  const elapsed = Date.now() - startTime;
                  const progress = Math.min(elapsed / transitionDuration, 1);
                  
                  setFlashCount(progress * 100);
                  
                  if (progress < 1) {
                      flashIntervalRef.current = requestAnimationFrame(animateTransition);
                  } else {
                      setFlashingNode(null);
                  }
              };
              
              requestAnimationFrame(animateTransition);
          };

          const animateLinkDeletion = (source, target) => {
              const startTime = Date.now();
              const shakeDuration = 300;
              const deletionDuration = 300;
              
              const animateShake = () => {
                  const now = Date.now();
                  const elapsed = now - startTime;
                  
                  if (elapsed < shakeDuration) {
                      const shakeProgress = elapsed / shakeDuration;
                      const shakeAmount = Math.sin(shakeProgress * Math.PI * 10) * 2 * (1 - shakeProgress);
                      
                      setActiveLinks(prev => 
                          prev.map(link => {
                              if (link.source === source && link.target === target) {
                                  return { ...link, shakeOffset: shakeAmount };
                              }
                              return link;
                          })
                      );
                      
                      requestAnimationFrame(animateShake);
                  } else {
                      animateFade();
                  }
              };
              
              const animateFade = () => {
                  const fadeStartTime = Date.now();
                  
                  const fadeAnimation = () => {
                      const now = Date.now();
                      const elapsed = now - fadeStartTime;
                      const fadeProgress = Math.min(elapsed / deletionDuration, 1);
                      
                      setActiveLinks(prev => 
                          prev.map(link => {
                              if (link.source === source && link.target === target) {
                                  return { ...link, deletionProgress: fadeProgress };
                              }
                              return link;
                          })
                      );
                      
                      if (fadeProgress < 1) {
                          requestAnimationFrame(fadeAnimation);
                      } else {
                          setActiveLinks(prev => 
                              prev.filter(link => 
                                  !(link.source === source && link.target === target)
                              )
                          );
                          
                          setTimeout(() => {
                              updateNodeColors();
                          }, 100);
                      }
                  };
                  
                  requestAnimationFrame(fadeAnimation);
              };
              
              requestAnimationFrame(animateShake);
          };

          const updateNodeColors = () => {
              const nodesToChange = [];
              const currentNodeDegrees = calculateNodeDegrees(activeLinks, dynamicFixedNodes);
              
              // Check which nodes should change color
              dynamicFixedNodes.forEach((node, index) => {
                  const nodeId = node.id;
                  if (nodeGroups[nodeId - 1] === 1) { // Only non-risk factor nodes can be converted
                      // Check if this node has enough risk factor connections to be influenced
                      const connectionCount = currentNodeDegrees[nodeId - 1] || 0;
                      if (connectionCount > 0) {
                          let riskFactorNeighbors = 0;
                          activeLinks.forEach(link => {
                              if (link.source === nodeId && nodeGroups[link.target - 1] === 2) {
                                  riskFactorNeighbors++;
                              } else if (link.target === nodeId && nodeGroups[link.source - 1] === 2) {
                                  riskFactorNeighbors++;
                              }
                          });
                          
                          if (riskFactorNeighbors >= 2) { // At least 2 risk factor neighbors
                              nodesToChange.push(nodeId);
                          }
                      }
                  }
              });
              
              // Apply color changes
              if (nodesToChange.length > 0) {
                  const nodeToChange = nodesToChange[Math.floor(Math.random() * nodesToChange.length)];
                  handleFlash(nodeToChange, 1, 2);
                  
                  setTimeout(() => {
                      setNodeGroups(prev => {
                          const next = [...prev];
                          next[nodeToChange - 1] = 2;
                          return next;
                      });
                      
                      setNodesPerGroup(prev => ({
                          group1: prev.group1 - 1,
                          group2: prev.group2 + 1
                      }));
                  }, 600);
              }
          };

          const handleSliderChange = (e) => {
              const newStep = parseInt(e.target.value, 10);
              setStep(newStep);
              
              // Recalculate everything for this step
              // For a real implementation, you'd use recomputeStateForStep here
              if (newStep === 0) {
                  setNodeGroups(initialGroups);
                  setActiveLinks(initialEdges);
                  setNodesPerGroup({
                      group1: initialGroups.filter(g => g === 1).length,
                      group2: initialGroups.filter(g => g === 2).length
                  });
                  setDynamicFixedNodes(fixedNodes);
                  setNodeIsolationCounters(Array(fixedNodes.length).fill(0));
                  setAddedNodeCount(0);
                  setRemovedNodeCount(0);
                  setLastNodeRemovalStep(-50);
              } else {
                  // For a simpler implementation, just replay the simulation up to the target step
                  // In a real application, this would need to be more sophisticated
              }
          };

          const handleSpeedChange = (e) => {
              setSpeed(parseInt(e.target.value, 10));
          };

          const handleStep = () => {
              if (step < changes.length) {
                  const change = changes[step];
                  
                  // Process the normal change first
                  if (change.type === 'color') {
                      handleFlash(change.nodeId, nodeGroups[change.nodeId - 1], change.newGroup);
                      setTimeout(() => {
                          setNodeGroups((prev) => {
                              const next = [...prev];
                              next[change.nodeId - 1] = change.newGroup;
                              return next;
                          });

                          setNodesPerGroup((prev) => {
                              const oldGroup = nodeGroups[change.nodeId - 1];
                              const newGroup = change.newGroup;
                              return {
                                  group1: prev.group1 + (newGroup === 1 ? 1 : 0) - (oldGroup === 1 ? 1 : 0),
                                  group2: prev.group2 + (newGroup === 2 ? 1 : 0) - (oldGroup === 2 ? 0 : 1),
                              };
                          });
                      }, 600);
                  } else if (change.type === 'edge') {
                      if (change.action === 'add') {
                          const sourceNode = fixedNodes[change.source - 1];
                          const nearbyNodes = findNearbyNodes(change.source, 100).filter(
                              (targetNodeId) =>
                                  !activeLinks.some(
                                      (link) =>
                                          (link.source === change.source && link.target === targetNodeId) ||
                                          (link.source === targetNodeId && link.target === change.source)
                                  )
                          );

                          if (nearbyNodes.length > 0) {
                              const targetNodeId = nearbyNodes[0];
                              setActiveLinks((prev) => [
                                  ...prev,
                                  {
                                      source: change.source,
                                      target: targetNodeId,
                                      key: `${change.source}-${targetNodeId}-${Date.now()}`,
                                      progress: 0,
                                  },
                              ]);

                              const startTime = Date.now();
                              const duration = 300;

                              const animate = () => {
                                  const now = Date.now();
                                  const elapsed = now - startTime;
                                  const progress = Math.min(elapsed / duration, 1);

                                  setActiveLinks((prev) =>
                                      prev.map((link) =>
                                          link.source === change.source && link.target === targetNodeId
                                              ? { ...link, progress }
                                              : link
                                      )
                                  );

                                  if (progress < 1) {
                                      requestAnimationFrame(animate);
                                  } else {
                                      setTimeout(() => {
                                          updateNodeColors();
                                      }, 100);
                                  }
                              };

                              requestAnimationFrame(animate);
                          }
                      } else if (change.action === 'delete') {
                          setActiveLinks((prev) =>
                              prev.map((link) => {
                                  if (link.source === change.source && link.target === change.target) {
                                      return { ...link, deleting: true, deletionProgress: 0, shakeOffset: 0 };
                                  }
                                  return link;
                              })
                          );
                          animateLinkDeletion(change.source, change.target);
                      }
                  }

                  const nodeAddSteps = [50, 100, 150, 200];
                  if (nodeAddSteps.includes(step) && addedNodeCount < 4) {
                      addNewNode();
                  }

                  const nodeDegreesCurrent = calculateNodeDegrees(activeLinks, dynamicFixedNodes);
                  setNodeIsolationCounters(prev => 
                      prev.map((counter, index) => {
                          const nodeId = dynamicFixedNodes[index]?.id;
                          if (!nodeId) return counter;
                          
                          const degree = nodeDegreesCurrent[nodeId - 1] || 0;
                          return degree > 0 ? 0 : counter + 1;
                      })
                  );

                  if (Math.random() < 0.02) {
                      removeIsolatedNode();
                  }

                  setStep((prev) => prev + 1);
              } else {
                  setIsPlaying(false);
              }
          };

          React.useEffect(() => {
              if (isPlaying) {
                  intervalRef.current = setInterval(() => {
                      if (step < changes.length) {
                          handleStep();
                      } else {
                          setIsPlaying(false);
                          clearInterval(intervalRef.current);
                      }
                  }, speed);

                  return () => clearInterval(intervalRef.current);
              }
          }, [isPlaying, step, speed]);

          const toggleHelp = () => {
              setShowHelp(!showHelp);
          };

          const nodeDegrees = calculateNodeDegrees(activeLinks, dynamicFixedNodes);

          return (
              <div className="container">
                  
                  <div className="stats">
                      <div className="stat-item">
                          <div>Nodes with risk factor:</div>
                          <div className="stat-value">
                              {nodesPerGroup.group2} ({Math.round((nodesPerGroup.group2 / (nodesPerGroup.group1 + nodesPerGroup.group2)) * 100)}%)
                          </div>
                      </div>
                      <div className="stat-item">
                          <div>Nodes without risk factor:</div>
                          <div className="stat-value">
                              {nodesPerGroup.group1} ({Math.round((nodesPerGroup.group1 / (nodesPerGroup.group1 + nodesPerGroup.group2)) * 100)}%)
                          </div>
                      </div>
                      <div className="stat-item">
                          <div>Number of connections:</div>
                          <div className="stat-value">{activeLinks.length}</div>
                      </div>
                  </div>
                  
                  <svg 
                      width="100%" 
                      height="100%" 
                      viewBox={`0 0 ${width} ${height}`}
                      style={{maxHeight: '680px'}}
                  >
                      <defs>
                          <filter id="glow">
                              <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                              <feFlood floodColor="gold" floodOpacity="0.5" result="glowColor"/>
                              <feComposite in="glowColor" in2="coloredBlur" operator="in" result="softGlow"/>
                              <feMerge>
                                  <feMergeNode in="softGlow"/>
                                  <feMergeNode in="SourceGraphic"/>
                              </feMerge>
                          </filter>
                      </defs>
                      
                      <g transform="translate(20, 20)">
                          <circle cx="10" cy="10" r="6" fill="#d3d3d3"/>
                          <text x="25" y="15" className="text-sm">Non Risk Factor</text>
                          <circle cx="10" cy="35" r="6" fill="#ff4d4d"/>
                          <text x="25" y="40" className="text-sm">Risk Factor</text>
                      </g>

                      {activeLinks.map((link) => {
                          const sourceNode = dynamicFixedNodes.find(node => node.id === link.source);
                          const targetNode = dynamicFixedNodes.find(node => node.id === link.target);
                          if (!sourceNode || !targetNode) return null;

                          const dx = targetNode.x - sourceNode.x;
                          const dy = targetNode.y - sourceNode.y;
                          const currentX = sourceNode.x + dx * (link.progress || 1);
                          const currentY = sourceNode.y + dy * (link.progress || 1);
                          const opacity = link.deleting ? (0.4 * (1 - (link.deletionProgress || 0))) : 0.4;
                          const transform = link.deleting ? `translate(${link.shakeOffset || 0},0)` : '';
                          
                          return (
                              <line
                                  key={link.key}
                                  x1={sourceNode.x}
                                  y1={sourceNode.y}
                                  x2={currentX}
                                  y2={currentY}
                                  stroke="#000"
                                  strokeWidth="1.5"
                                  strokeOpacity={opacity}
                                  transform={transform}
                              />
                          );
                      })}
                      
                      {dynamicFixedNodes.map((node) => (
                          <g key={node.id} transform={`translate(${node.x},${node.y})`}>
                              <circle
                                  r={Math.max(4, Math.min(18, 3 + (nodeDegrees[node.id - 1] || 0) * 2.5))}
                                  fill={node.id === flashingNode 
                                      ? interpolateColor(
                                          colors[nodeGroups[node.id - 1] - 1] || colors[0], 
                                          colors[nodeGroups[node.id - 1] === 1 ? 1 : 0] || colors[0], 
                                          flashCount/100
                                      ) 
                                      : colors[nodeGroups[node.id - 1] - 1] || colors[0]}
                                  opacity="0.9"
                                  style={{ transition: "fill 500ms ease-in-out, r 300ms ease-out" }}
                              />
                          </g>
                      ))}
                  </svg>

                  <div className="controls">
                      <div className="control-group">
                          <button onClick={() => setIsPlaying(!isPlaying)}>
                              {isPlaying ? 'Stop' : 'Start'}
                          </button>
                          <button onClick={() => !isPlaying && handleStep()} disabled={isPlaying || step >= changes.length}>
                              Next step
                          </button>
                          <div className="slider-container">
                              <label>Step {step} / {changes.length}</label>
                              <input 
                                  type="range" 
                                  min="0" 
                                  max={changes.length} 
                                  step="1"
                                  value={step} 
                                  onChange={handleSliderChange}
                              />
                          </div>
                          <div className="slider-container">
                              <label>Step duration: {speed} ms</label>
                              <input 
                                  type="range" 
                                  min="15" 
                                  max="1000" 
                                  value={speed} 
                                  onChange={handleSpeedChange}
                              />
                          </div>
                      </div>
                      
                  </div>
                  
                  
              </div>
          );
      }

      ReactDOM.render(<App />, document.getElementById('root'));
  </script>
</body>
</html>
